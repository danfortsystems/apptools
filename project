#!/usr/bin/env bash

# Exit immediately if a command exits with a non-zero status
set -euo pipefail

# Enable debugging output to trace commands.
# set -x

# Load utility functions
source "$(dirname "$0")/_utils"

# Check for help flag
if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
	print_error "Usage: project <action> [arguments]"
	print_error ""
	print_error "Available actions:"
	print_error "build [--dest <path>] [--only app|db] [--db-url <url>] [--db-path <path>] [--db-reset-ok]"
	print_error "Build the project"
	print_error ""
	print_error "deploy [--service-name <name>] [--update-level <level>]"
	print_error "Deploy the project to Render.com"
	print_error ""
	print_error "start [--db-url <url>] [--db-path <path>] [--port <port>]"
	print_error "Start the server"
	print_error ""
	print_error "test [--build-dir <dir>] [--no-db-create] [--db-url <url>] [--keep-db-file] [--log-dir <dir>] [--only <types>] [--fast]"
	print_error "Run tests"
	print_error ""
	print_error "dev [--db-url <url>] [--port <port>]"
	print_error "Start development mode with file watching"
	print_error ""
	print_error "deps [--reset <targets>]"
	print_error "Manage dependencies"
	print_error ""
	print_error "install"
	print_error "Install the project"
	exit 1
fi

# Parse args to construct command
action="$1"
shift  # Remove 1st arg (action) from the args list
command="$action"
for arg in "$@"; do
	command="${command} $arg"
done

# Inject environment variables
source _env

# Set log directory, file path, and command, based on the action
TIMESTAMP=$(date +"%s__%Y-%m-%d__%I-%M-%S_%p")
if [ "$action" = "test" ]; then
	LOG_DIRECTORY="./logs/$action/$TIMESTAMP"
    LOG_FILE_PATH="./${LOG_DIRECTORY}/consolidated.log"
	command="${command} --log-dir ${LOG_DIRECTORY}"
else
	LOG_DIRECTORY="./logs/$action"
    LOG_FILE_PATH="./${LOG_DIRECTORY}/${TIMESTAMP}.$action.log"
fi

# Create the log directory, if it does not exist
mkdir -p "$LOG_DIRECTORY"

# Set color codes to be stripped out of log
strip_pattern="s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGKABCDHJKSfn]//g"

# Run the command
start_timestamp=$(date +%s)
formatted_start_time=$(date -r "$start_timestamp" "+%a, %b %d %Y at %I:%M:%S %p")
print_warning_header "\nSTARTED ${italic}$action${unitalic} at $formatted_start_time\n"

# Run the command and capture exit code
set +e
( ${command} 2>&1 | (trap '' SIGINT SIGHUP SIGPIPE; tee >(sed -E "$strip_pattern" > "$LOG_FILE_PATH")) )
exit_code=$?
set -e

end_timestamp=$(date +%s)
seconds=$((end_timestamp-start_timestamp))

# Report completion or failure
if [ $exit_code -eq 0 ]; then
    formatted_end_time=$(date -r "$end_timestamp" "+%a, %b %d %Y at %I:%M:%S %p")
    print_success_header "\nFINISHED ${italic}$action${unitalic} after ${seconds}s\n"
else
    print_error_header "\nFAILED ${italic}$action${unitalic} (exit code $exit_code) after ${seconds}s\n"
    exit $exit_code
fi
