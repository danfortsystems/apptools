#!/usr/bin/env bash

# Exit immediately if a command exits with a non-zero status
set -euo pipefail

# Enable debugging output to trace commands.
# set -x

# GitHub repository information
REPO_URL="https://raw.githubusercontent.com/danfortsystems/apptools/main"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
ARCHIVE_URL="https://github.com/danfortsystems/apptools/archive/refs/heads/main.tar.gz"

# Check if AppTools is installed locally
find_local_installation() {
    local local_paths=(
        "$SCRIPT_DIR"
        "$HOME/.local/bin/apptools"
        "$HOME/.local/share/apptools"
        "/usr/local/bin/apptools"
        "/opt/apptools"
    )

    for path in "${local_paths[@]}"; do
        if [ -d "$path" ] && [ -f "$path/_utils" ]; then
            echo "$path"
            return 0
        fi
    done

    echo ""
    return 1
}

# Create or get AppTools directory
setup_app_tools_dir() {
    # Check for local installation first
    local_installation=$(find_local_installation)
    if [ -n "$local_installation" ]; then
        echo "$local_installation"
        return 0
    fi

    # Create temporary directory
    local temp_dir
    temp_dir=$(mktemp -d)

    # Download and extract archive
    if command -v curl >/dev/null 2>&1; then
        if ! curl -fsSL "$ARCHIVE_URL" | tar -xzf - -C "$temp_dir"; then
            echo "ERROR: Failed to download AppTools archive" >&2
            rm -rf "$temp_dir"
            return 1
        fi
    elif command -v wget >/dev/null 2>&1; then
        if ! wget -qO - "$ARCHIVE_URL" | tar -xzf - -C "$temp_dir"; then
            echo "ERROR: Failed to download AppTools archive" >&2
            rm -rf "$temp_dir"
            return 1
        fi
    else
        echo "ERROR: Neither curl nor wget is available" >&2
        return 1
    fi

    # Find the extracted directory
    local extracted_dir
    extracted_dir=$(find "$temp_dir" -maxdepth 1 -type d | head -n1)

    echo "$extracted_dir"
    return 0
}

# Check for help flag
if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
	echo "Usage: project <action> [arguments]" >&2
	echo "" >&2
	echo "Available actions:" >&2
	echo "build [--dest <path>] [--only app|db] [--db-url <url>] [--db-path <path>] [--db-reset-ok]" >&2
	echo "Build the project" >&2
	echo "" >&2
	echo "deploy [--update-level <path|minor|major>] [--include <files>] [--exclude <files>] --repo <url>" >&2
	echo "Deploy the project to a git repository" >&2
	echo "" >&2
	echo "start [--db-url <url>] [--db-path <path>] [--port <port>]" >&2
	echo "Start the server" >&2
	echo "" >&2
	echo "test [--build-dir <dir>] [--no-db-create] [--db-url <url>] [--keep-db-file] [--log-dir <dir>] [--only <types>] [--fast]" >&2
	echo "Run tests" >&2
	echo "" >&2
	echo "dev [--db-url <url>] [--port <port>]" >&2
	echo "Start development mode with file watching" >&2
	echo "" >&2
	echo "deps [--reset <targets>]" >&2
	echo "Manage dependencies (js, db, containers, browsers)" >&2
	echo "" >&2
	echo "install --src <url OR folder path> --target <local-install-folder-path> --main <main-binary-file> [--version <version-number-tag>]" >&2
	echo "Install a project from source" >&2
	exit 1
fi

# Parse args to construct command
action="$1"
shift  # Remove 1st arg (action) from the args list
command="$action"
for arg in "$@"; do
	command="${command} $arg"
done


# Setup AppTools directory (local installation or temp directory)
APPTOOLS_DIR_PATH=$(setup_app_tools_dir)
if [ $? -ne 0 ] || [ -z "$APPTOOLS_DIR_PATH" ]; then
    echo "ERROR: Failed to setup AppTools directory" >&2
    exit 1
fi

# Load utility and environment functions
source "$APPTOOLS_DIR_PATH/_utils"
source "$APPTOOLS_DIR_PATH/_env"

# Set log directory, file path, and command, based on the action
TIMESTAMP=$(date +"%s__%Y-%m-%d__%I-%M-%S_%p")
if [ "$action" = "test" ]; then
	LOG_DIRECTORY="./logs/$action/$TIMESTAMP"
    LOG_FILE_PATH="./${LOG_DIRECTORY}/consolidated.log"
else
	LOG_DIRECTORY="./logs/$action"
    LOG_FILE_PATH="./${LOG_DIRECTORY}/${TIMESTAMP}.$action.log"
fi

# Create the log directory, if it does not exist
mkdir -p "$LOG_DIRECTORY"

# Set color codes to be stripped out of log
strip_pattern="s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGKABCDHJKSfn]//g"

# Run the command
start_timestamp=$(date +%s)
formatted_start_time=$(date -r "$start_timestamp" "+%a, %b %d %Y at %I:%M:%S %p")
print_warning_header "\nSTARTED ${italic}$action${unitalic} at $formatted_start_time\n"

# Run the command with APPTOOLS_DIR_PATH injected and capture exit code
set +e
( APPTOOLS_DIR_PATH="$APPTOOLS_DIR_PATH" "$APPTOOLS_DIR_PATH/$action" "$@" 2>&1 | (trap '' SIGINT SIGHUP SIGPIPE; tee >(sed -E "$strip_pattern" > "$LOG_FILE_PATH")) )
exit_code=$?
set -e

end_timestamp=$(date +%s)
seconds=$((end_timestamp-start_timestamp))

# Report completion or failure
if [ $exit_code -eq 0 ]; then
    formatted_end_time=$(date -r "$end_timestamp" "+%a, %b %d %Y at %I:%M:%S %p")
    print_success_header "\nFINISHED ${italic}$action${unitalic} after ${seconds}s\n"
else
    print_error_header "\nFAILED ${italic}$action${unitalic} (exit code $exit_code) after ${seconds}s\n"
    exit $exit_code
fi

# Clean up temporary directory if it was created
if [[ "$APPTOOLS_DIR_PATH" == *"tmp"* ]]; then
    rm -rf "$APPTOOLS_DIR_PATH"
fi
