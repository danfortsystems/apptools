#!/usr/bin/env bash

# Builds code & db, tests & tags code, and then deploys the app to Render.com
# An optional --service-name parameter can be used to specify the target Render service (default is picked from package.json)
# An optional --update-level parameter can be used to specify repo update level: "patch" (default), "minor", or "major"
# Requires that the setup.sh script has been run first to set up the tooling commands

# Terminate script if a command exits with a non-zero status.
set -e

source "$APPTOOLS_DIR_PATH/_utils"

# Default arguments
# Get and store project name
PROJECT_NAME=$(node -p "require('./package.json').name" | sed 's/[^a-z0-9-]//g' | tr '[:upper:]' '[:lower:]')
UPDATE_LEVEL="patch"
REPO_URL="https://github.com/danfortsystems/$PROJECT_NAME"
INCLUDE_FILES=""
EXCLUDE_FILES=""

# Parse script arguments
while [[ $# -gt 0 ]]; do
	case "$1" in
	--update-level)
		UPDATE_LEVEL="$2"
		shift 2
		;;
	--repo)
		REPO_URL="$2"
		shift 2
		;;
	--include)
		INCLUDE_FILES="$2"
		shift 2
		;;
	--exclude)
		EXCLUDE_FILES="$2"
		shift 2
		;;
	*)
		echo "Usage: $0 [--update-level <patch|minor|major>] [--repo <git_repo_url>] [--include <files_list>] [--exclude <files_list>]"
		exit 1
		;;
	esac
done

# Validate update level
if [[ ! "$UPDATE_LEVEL" =~ ^(patch|minor|major)$ ]]; then
	print_error "Invalid version level. Use 'patch', 'minor', or 'major'."
	exit 1
fi


# Ensure project is git-wise clean (no pending changes)
print_header "Checking git status"
if [[ -n "$(git status --porcelain)" ]]; then
	print_error "Repository is not clean. Please commit or stash all changes before deploying."
	print_error "Uncommitted changes:"
	git status --porcelain
	exit 1
fi
print_step "Repository is clean"

# Create temporary build directory
BUILD_DIR=$(mktemp -d)
ORIGINAL_DIR=$(pwd)

# Single cleanup function that handles both directory cleanup and cd back
cleanup() {
	# Clean up temporary build directory
	rm -rf "$BUILD_DIR"
	# Return to original directory
	cd "$ORIGINAL_DIR" 2>/dev/null || true
}
trap cleanup EXIT

print_header "Creating temporary build directory"
print_step "Temporary directory: $BUILD_DIR"

# Build code and db to temporary directory using production database URL
print_header "Building to temporary directory..."
./build --dest "$BUILD_DIR" --db-url "$DATABASE_URL" --db-reset-ok

# Run tests (keeping db file for deployment)
print_header "Running tests..."
if [ -n "$DATABASE_URL" ]; then
	./test --keep-db-file --build-dir "$BUILD_DIR" --db-url "$DATABASE_URL"
else
	print_warning "DATABASE_URL not set, skipping database tests"
	./test --keep-db-file --build-dir "$BUILD_DIR"
fi

# Bump pkg version according to update level arg (will also create a matching tag)
print_header "Updating package version"

if ! npm version "$UPDATE_LEVEL"; then
	print_error "Failed to bump version with npm. This might be due to:"
	print_error "  - Uncommitted changes (already checked above)"
	print_error "  - Invalid version level"
	print_error "  - Network issues"
	print_error "Please check the error above and try again."
	exit 1
fi

PACKAGE_VERSION=$(node -p "require('./package.json').version")
print_step "New version: $PACKAGE_VERSION"

# Push git repository (including tags) to the main remote
print_header "Pushing to git repository"
git push origin main --follow-tags

# Create package.json for deployment
print_step "Creating package.json for deployment"
# Get the current commit tag
COMMIT_TAG=$(git describe --tags --exact-match HEAD 2>/dev/null || git rev-parse HEAD)
cat >"$BUILD_DIR/package.json" <<EOF
{
	"name": "$PROJECT_NAME",
	"version": "$PACKAGE_VERSION",
	"repository": {
		"type": "git",
		"url": "$REPO_URL"
	},
	"commit_tag": "$COMMIT_TAG"
}
EOF


# Initialize git repo in the build directory
print_step "Initializing git repository in build directory"
# ORIGINAL_DIR is already set

cd "$BUILD_DIR"

# Apply include/exclude filtering
print_step "Applying file filtering..."

IFS=',' read -ra INCLUDE_ARRAY <<< "${INCLUDE_FILES:-}"
IFS=',' read -ra EXCLUDE_ARRAY <<< "${EXCLUDE_FILES:-}"

RSYNC_ARGS=(-a)

# Includes
if [[ -n "${INCLUDE_FILES:-}" ]]; then
	# First, include all directories to enable traversal
	RSYNC_ARGS+=(--include="*/")
	for pattern in "${INCLUDE_ARRAY[@]}"; do
		pattern="$(echo "$pattern" | xargs)"
		[[ -n "$pattern" ]] && RSYNC_ARGS+=(--include="$pattern")
	done
fi

# Excludes (user)
for pattern in "${EXCLUDE_ARRAY[@]}"; do
	pattern="$(echo "$pattern" | xargs)"
	[[ -n "$pattern" ]] && RSYNC_ARGS+=(--exclude="$pattern")
done

# Always exclude git
RSYNC_ARGS+=(--exclude=".git")

# If includes were specified, exclude everything else LAST
if [[ -n "${INCLUDE_FILES:-}" ]]; then
	RSYNC_ARGS+=(--exclude="*")
fi

rm -rf filtered
mkdir filtered
rsync "${RSYNC_ARGS[@]}" ./ filtered/

# Clean directory safely
find . -mindepth 1 -maxdepth 1 ! -name filtered -exec rm -rf {} +

# Move filtered contents back
rsync -a filtered/ ./
rm -rf filtered

git init
git add .
git commit -m "Deployed version $PACKAGE_VERSION"

print_step "Done"

# Set git remote for GitHub and push
print_header "Pushing to GitHub"
# Extract repo name from REPO_URL for remote
REPO_NAME=$(basename "$REPO_URL" .git)
git remote add origin "$REPO_URL"
git push -u origin main --force
print_step "Done"

# Clean up will be handled by the EXIT trap

print_step "Deployment preparation complete"
print_step "Deployed version: $PACKAGE_VERSION"
print_step "Repository: $REPO_URL"