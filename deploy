#!/usr/bin/env bash

# Builds code & db, tests & tags code, and then deploys the app to Render.com
# An optional --service-name parameter can be used to specify the target Render service (default is picked from package.json)
# An optional --update-level parameter can be used to specify repo update level: "patch" (default), "minor", or "major"
# Requires that the setup.sh script has been run first to set up the tooling commands

# Terminate script if a command exits with a non-zero status.
set -e

source "$APPTOOLS_DIR_PATH/_utils"

# Default arguments
# Get and store project name
PROJECT_NAME=$(node -p "require('./package.json').name" | sed 's/[^a-z0-9-]//g' | tr '[:upper:]' '[:lower:]')
UPDATE_LEVEL="patch"
REPO_URL="https://github.com/danfortsystems/$PROJECT_NAME"
INCLUDE_FILES=""
EXCLUDE_FILES=""

# Parse script arguments
while [[ $# -gt 0 ]]; do
	case "$1" in
	--update-level)
		UPDATE_LEVEL="$2"
		shift 2
		;;
	--repo)
		REPO_URL="$2"
		shift 2
		;;
	--include)
		INCLUDE_FILES="$2"
		shift 2
		;;
	--exclude)
		EXCLUDE_FILES="$2"
		shift 2
		;;
	*)
		echo "Usage: $0 [--update-level <patch|minor|major>] [--repo <git_repo_url>] [--include <files_list>] [--exclude <files_list>]"
		exit 1
		;;
	esac
done

# Validate update level
if [[ ! "$UPDATE_LEVEL" =~ ^(patch|minor|major)$ ]]; then
	print_error "Invalid version level. Use 'patch', 'minor', or 'major'."
	exit 1
fi


# print_header "Deploying $UPDATE_LEVEL update to repo $REPO_URL"

# Create temporary build directory
BUILD_DIR=$(mktemp -d)
ORIGINAL_DIR=$(pwd)

# Single cleanup function that handles both directory cleanup and cd back
cleanup() {
	# Clean up temporary build directory
	rm -rf "$BUILD_DIR"
	# Return to original directory
	cd "$ORIGINAL_DIR" 2>/dev/null || true
}
trap cleanup EXIT

print_header "Creating temporary build directory"
print_step "Temporary directory: $BUILD_DIR"

# Build code and db to temporary directory using production database URL
print_header "Building to temporary directory..."
./build --dest "$BUILD_DIR" --db-url "$DATABASE_URL" --db-reset-ok

# Run tests (keeping db file for deployment)
print_header "Running tests..."
if [ -n "$DATABASE_URL" ]; then
	./test --keep-db-file --build-dir "$BUILD_DIR" --db-url "$DATABASE_URL"
else
	print_warning "DATABASE_URL not set, skipping database tests"
	./test --keep-db-file --build-dir "$BUILD_DIR"
fi

# Bump pkg version according to update level arg (will also create a matching tag)
print_header "Updating package version"
npm version "$UPDATE_LEVEL"
PACKAGE_VERSION=$(node -p "require('./package.json').version")
print_step "New version: $PACKAGE_VERSION"

# Push git repository (including tags) to the main remote
print_header "Pushing to git repository"
git push origin main --follow-tags

# Create package.json for deployment
print_step "Creating package.json for deployment"
# Get the current commit tag
COMMIT_TAG=$(git describe --tags --exact-match HEAD 2>/dev/null || git rev-parse HEAD)
cat >"$BUILD_DIR/package.json" <<EOF
{
	"name": "$PROJECT_NAME",
	"version": "$PACKAGE_VERSION",
	"repository": {
		"type": "git",
		"url": "$REPO_URL"
	},
	"commit_tag": "$COMMIT_TAG"
}
EOF


# Initialize git repo in the build directory
print_step "Initializing git repository in build directory"
# ORIGINAL_DIR is already set

cd "$BUILD_DIR"
git init
git add .
git commit -m "Deployed version $PACKAGE_VERSION"

print_step "Done"

# Set git remote for GitHub and push
print_header "Pushing to GitHub"
# Extract repo name from REPO_URL for remote
REPO_NAME=$(basename "$REPO_URL" .git)
git remote add origin "$REPO_URL"
git push -u origin main --force
print_step "Done"

# Clean up will be handled by the EXIT trap

print_step "Deployment preparation complete"
print_step "Deployed version: $PACKAGE_VERSION"
print_step "Repository: $REPO_URL"