#!/usr/bin/env bash

# Install script for AppTools

# Usage:
	#	<runner> `install --src <url OR folder path> --target <local-install-folder-path> --main <main-binary-file> [--version <version-number-tag>]`

# Where:
	#	<runner> is one of:
	#	  - project (from AppTools)
	#
	#	--src <url OR folder path>			- Source: GitHub repo URL or local folder path
	#	--target <local-install-folder-path>	- Target local folder path to install files
	#	--main <main-binary-file>			- Name of primary executable file
	#	--version <version-number-tag>		- Version tag to install (GitHub only)

# Remarks:
	#	- Creates the target installation directory if it doesn't exist
	#	- For GitHub URLs: downloads archive, extracts, and moves contents to target
	#	- For local paths: copies files from source to target
	#	- Sets proper permissions on the main executable
	#	- Creates symlink in ~/.local/bin
	#	- Runs initialization tasks with --init flag
	#	- Verifies installation by checking --version flag
	#	- Validates that no init.sql or migrate.sql files remain after initialization

# Examples:
	#	install --src https://github.com/user/repo.git --target /path/to/install --main myapp --version v1.0.0
	#	install --src ./local/path --target ~/apps/myapp --main myapp
#

# Set immediate exit on error (including undefined variables, pipelines)
set -euo pipefail

# Load utility functions from AppTools directory. APPTOOLS_DIR_PATH is set by the project script when calling this script
source "$APPTOOLS_DIR_PATH/_utils"

command_exists() { command -v "$1" >/dev/null 2>&1; }

# Defaults
MAIN=""
SOURCE=""
TARGET=""
VERSION=""

# Argument parsing (named args only)
while [ $# -gt 0 ]; do
  case "$1" in
    --src)
      SOURCE="$2"; shift 2 ;;
    --target)
      TARGET="$2"; shift 2 ;;
    --main)
      MAIN="$2"; shift 2 ;;
    --version)
      VERSION="$2"; shift 2 ;;
    *)
      print_error "Unknown option: $1" && exit 1 ;;
  esac
done

if [ -z "$MAIN" ]; then
	print_error "--main is required"
	exit 1
fi

# Derived defaults
if [ -z "$SOURCE" ]; then
  if [ -n "$VERSION" ]; then
    SOURCE="https://github.com/danfortsystems/$MAIN/archive/refs/tags/$VERSION.tar.gz"
  else
    SOURCE="https://github.com/danfortsystems/$MAIN/archive/refs/heads/main.tar.gz"
  fi
fi

# Normalize GitHub repo URL to an archive URL
if [[ "$SOURCE" =~ ^https://github.com/([^/]+)/([^/]+)(\.git)?$ ]]; then
  OWNER="${BASH_REMATCH[1]}"
  REPO="${BASH_REMATCH[2]}"
  if [ -n "$VERSION" ]; then
    SOURCE="https://github.com/$OWNER/$REPO/archive/refs/tags/$VERSION.tar.gz"
  else
    SOURCE="https://github.com/$OWNER/$REPO/archive/refs/heads/main.tar.gz"
  fi
fi

PROJECT_NAME="$REPO"

TARGET="${TARGET:-$HOME/.local/share/$PROJECT_NAME}"

# Prepare filesystem
TMPDIR="$(mktemp -d)"
trap 'rm -rf "$TMPDIR"' EXIT

mkdir -p "$TARGET"
TARGET="$(cd "$TARGET" && pwd)"

# Fetch source
print_step "Installing '$MAIN'"
print_step "Source: $SOURCE"
print_step "Target: $TARGET"

case "$SOURCE" in
  http://*|https://*|ftp://*)
    # Download and extract archive from URL
    command_exists tar || (print_error "tar is required" && exit 1)
    if command_exists curl; then
      curl -fsSL "$SOURCE" | tar -xzf - -C "$TMPDIR"
    elif command_exists wget; then
      wget -qO- "$SOURCE" | tar -xzf - -C "$TMPDIR"
    else
      print_error "curl or wget required" && exit 1
    fi
    # Find the extracted directory name (first directory in temp folder)
    SRC_DIR="$(find "$TMPDIR" -mindepth 1 -maxdepth 1 -type d | head -n1)"
    ;;
  *)
    # Use local directory as source
    [ -d "$SOURCE" ] || (print_error "Source directory does not exist" && exit 1)
    SRC_DIR="$(cd "$SOURCE" && pwd)"
    ;;
esac

# Validate contents
[ -f "$SRC_DIR/$MAIN" ] || (print_error "Executable '$MAIN' not found in source" && exit 1)

# Install files
print_step "Copying files"
cp -R "$SRC_DIR/"* "$TARGET/"

# Set execute permissions on the main file and any files with shebangs
chmod +x "$TARGET/$MAIN"

# Find and set execute permissions on files with shebangs
find "$TARGET" -type f -exec grep -l '^#!' {} \; | xargs chmod +x 2>/dev/null || true

if [ -n "$VERSION" ]; then
	echo "$VERSION" > "$TARGET/VERSION"
fi

# Symlink
BIN_DIR="$HOME/.local/bin"
SYMLINK_PATH="$BIN_DIR/$MAIN"

mkdir -p "$BIN_DIR"
ln -sf "$TARGET/$MAIN" "$SYMLINK_PATH"
print_step "Symlinked $SYMLINK_PATH → $TARGET/$MAIN"

# PATH check
PATH_OK=0
case ":$PATH:" in
  *":$BIN_DIR:"*) PATH_OK=1 ;;
esac

# Run executable (init/migrate)
print_step "Running '$MAIN' --init for initialization (errors ignored)"
(
  cd "$TARGET"
  "./$MAIN" --init >/dev/null 2>&1 || true
)

# Validate SQL cleanup
if [ -f "$TARGET/init.sql" ] || [ -f "$TARGET/migrate.sql" ]; then
  print_error "init.sql or migrate.sql still present — initialization failed"
  exit 1
fi

# Report success
print_header "Installation complete!"
print_step "Command: $MAIN"
print_step "Version: $("$TARGET/$MAIN" --version 2>/dev/null | head -n1 || echo unknown)"
print_step "Installed: $TARGET"

if [ "$PATH_OK" -eq 1 ]; then
  print_step "'$MAIN' is available immediately."
else
  print_warning "'$BIN_DIR' is not in your PATH."
  print_step "Add this to your shell config:"
  print_step "export PATH=\"\$PATH:$BIN_DIR\""
fi

print_step "Run '$MAIN --help' to get started."
