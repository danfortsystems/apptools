AppTools: Specifications
-------------------------------------------------------
Updated: January 29, 2026
Version: 0.1.0

OVERVIEW
	AppTools is a set of Bash-based command-line tools for orchestrating common development and project management tasks within the monorepo. It replaces project-specific shell scripts with a unified toolset, ensuring consistency and simplifying maintenance.

	The tools operate as simple Bash scripts that respond to environment variables to determine their behavior for each target project. This lightweight approach provides flexibility without requiring complex configuration files.

	This document provides the technical specifications for the AppTools.

SYSTEM ARCHITECTURE

	Components
		- Project dispatcher script (Main Entry Point): The `project` script serves as a dispatcher, and the other major command/action script files are called with it, e.g., project deps <arguments ...>. If AppTools is installed locally, the project command should be available on the machine as an executable, so we can run it immediately. If not, we need to get it from Github and run it with sh it directly from its Github URL, with a command like curl -fsSL <url-to-project-script> | sh -s -- <command> <...arguments>. When the project script is invoked, it is passed the specific command script to run, and that command's arguments.

		- Core Tools: Individual Bash scripts for specific actions (deps, build, test, dev, start, deploy, install).

		- Environment Handler: The `_env` script loads variables from a `.env` file into the environment.

		- Utility Functions: Shared functions in `_utils` for consistent logging and error handling.

	Prerequisites
		- Bash shell
		- Standard Unix/Linux tools (curl, wget, tar, rsync, sed, openssl)
		- Git version control (for deployment and version operations)
		- PostgreSQL and SQLite database engines (if using database features)
		- Node.js runtime and package manager (pnpm/bun/npm - only for projects using Node.js)
		- Podman (Container Engine): For managing local development services that run in containers, such as MinIO (S3-compatible object storage) and MailHog (SMTP server). AppTools commands like `deps`, `start`, and `test` interact with Podman to ensure these services are available.
			Installation
			- macOS (via Homebrew): brew install podman && podman machine init && podman machine start
			- Linux: Refer to your distribution's documentation (e.g., `sudo apt install podman` for Debian/Ubuntu, `sudo dnf install podman` for Fedora).

	Execution Context
		The tools are designed to be executed from the root directory of a target project. They implicitly determine the current project context by reading a `.env` file (if present) and using environment variables to control their behavior. All operations are relative to the current working directory.

	Dynamic Recursive Loading
		As alluded to in the description of the project command, AppTools can work without being locally installed. The dispatcher script "project" can be loaded from its url and run with sh, and it in turn loads and uses any script files it needs that do not exist locally in a similar manner, and those script files also load/use any files they depend on a similar manner, etc. 
		
		When executed remotely, the project script creates a temporary directory (or uses an existing local installation) and downloads all required scripts from the GitHub repository. The APPTOOLS_DIR_PATH environment variable is set to point to this directory, allowing all scripts to reference each other using relative paths like "$APPTOOLS_DIR_PATH/_utils". After execution, the temporary directory is cleaned up. This centralized approach ensures all scripts are consistently available and avoids redundant downloads.

	Script Invocation Principle
		Whenever a script (that is typically called with the "project" dispatcher) needs to call another of the scripts, it should do so directly, i.e., without again calling it with the "project" dispatcher. This avoids the overhead of the dispatcher and ensures proper argument passing without potential parsing issues.

	Directory Structure
		The AppTools project files are organized in a flat structure for simplicity and ease of installation:

		Root Directory:
			- project			# Main dispatcher script (executable)
			- deps				# Dependencies management (executable)
			- build				# Build automation (executable)
			- test				# Test execution (executable)
			- dev				# Development server with file watching (executable)
			- start				# Production server (executable)
			- deploy			# Deployment automation (executable)
			- install			# CLI tool installation (executable)
			- _env				# Environment variable loader (executable utility)
			- _utils			# Shared utility functions (executable utility)
			- _postgres			# PostgreSQL-specific database operations (executable utility)
			- _sqlite			# SQLite-specific database operations (executable utility)

		When installed locally, all files are placed in the installation directory (e.g., ~/.local/share/apptools/). A symlink to the main executable is created in ~/.local/bin/ for easy access.

		Internal Organization:
			- User-facing commands: Files without underscore prefixes (project, deps, build, etc.)
			- Internal utilities: Files with underscore prefixes (_env, _utils, _postgres, _sqlite)

COMMAND LINE INTERFACE

	Main Command: `project`
		Usage: project <action> [arguments]

		Behavior
			The `project` script is a dispatcher that:

			- Sets up a context for the command that is to be run. This requires sourcing the files _utils (to use shared functions) and _env (to load env variables from `.env` file if present). If AppTools is installed locally, then those files are in the same folder and can immediately be used. Otherwise, the project script needs to curl/wget them and source them, preferably in place without having to actually save them as files. 

			- Sets a log folder and file path relative to any project folder it is running it, If it does not appear to be running at a project root (no package.json, etc) then no log folder/file path should be set, and no logging should occur.

			- Runs the action command, optionally logging its output, report the result, and exit. Again, if AppTools is installed locally, then the command script file exists, otherwise it needs to be loaded from its url in the apptools repo. The command script file also loads any files it depends on from their AppTools repo url as it runs.

	Available Actions:

		Deps
			Usage: deps [--reset <targets>]

			Environment Variables:
				- DATABASE_URL: Controls PostgreSQL database reset/install (if set, processes Postgres)
				- DB_PATH: Controls SQLite database reset/install (if set, processes SQLite)
				- OBJECT_STORAGE_BUCKET: Controls MinIO bucket creation
				- MSG_FROM_EMAIL_ADDRESS: Controls MailHog per-project isolation
				- PLAYWRIGHT_BROWSERS_PATH: Controls Playwright browser installation

			Behavior:
				- Manages dependencies based on environment variables
				- Valid targets: js (Node.js packages), db (databases), containers (Podman), browsers (Playwright)
				- If no --reset specified, installs all available dependencies
				- If --reset specified, resets specified targets then installs all

			Examples:
				project deps								# Install all available dependencies
				project deps --reset						# Reset and reinstall all
				project deps --reset db,js					# Reset db and js, install others

		build [--dest <path>] [--only <targets>] [--db-url <url>] [--db-path <path>] [--db-reset-ok]
			Build application code, executable, and/or database

			Options:
				--dest <path>: Output directory for build artifacts (default: ./dist)
				--only <targets>: Comma-separated list of targets to build: app, exc, and/or db (default: all)
				--db-url <url>: PostgreSQL connection URL for database build (default: DATABASE_URL env var)
				--db-path <path>: SQLite database file path for database build (default: DB_PATH env var)
				--db-reset-ok: Allow database reset when no migration script exists (default: disabled)

			Behavior:
				Building the various targets involve:
					- Application code (app): Typechecking and bundling client & server app code
					- Executable (exc): Creating self-contained platform specific executable (uses bin/main.ts entry point by convention). Output is named {package}-{os}-{architecture} (e.g., myapp-macos-arm64, myapp-linux-x64)
					- Db (db): Generating db init/migration scripts as necessary

				The db build consolidates the schema sql files into a single db.init.sql script with proper dependency ordering, in the build output folder, that acts as a reference script for (re)creating the correct schema. It then checks if the db schema files are compatible with the db referenced by the effective db url or db path argument and proceeds as follows:
					- If the schema has not changed, it does nothing further.
					- If the schema has data and has changed, it expects a .migrate.sql file in the schema sql script folder, containing migration logic to preserve existing data, which is copied to the build output folder.
					- Otherwise if the schema has changed but has no data or --db-reset-ok is passed, it creates another consolidated init script (but this time named as db.migrate.sql) in the build output folder. 
					
					Whenever the app is next started or tested, any existing db.migrate.sql in the build output folder is applied to the attached db and deleted on success.

			Examples:
				project build									# Full build to ./dist
				project build --dest ./build					# Build to custom directory
				project build --only db	--db-path ./path/to/db	# Database build only with db path specified
				project build --only app --dest ./build			# App build only to custom directory

		Test
			Usage: test [--build-dir <dir>] [--no-db-create] [--db-url <url>] [--keep-db-file] [--log-dir <dir>] [--only <types>] [--fast]

			Arguments:
				- --build-dir: Directory containing build artifacts (default: ./dist)
				- --no-db-create: Don't create a random test database (uses DATABASE_URL as-is)
				- --db-url: Database connection URL (overrides DATABASE_URL env var)
				- --keep-db-file: Keep db.migrate.sql file after successful migration
				- --log-dir: Custom directory for test logs (default: ./logs/test/<timestamp>)
				- --only: Run only specified test types (comma-separated: units,api,gui,e2e)
				- --fast: Use fast Playwright configuration (Chrome only, faster execution)

			Examples:
				project test							# Run all tests
				project test --only units				# Run only unit tests
				project test --only api,gui				# Run API and GUI tests
				project test --fast						# Run all tests with fast config

			Behavior:
				- Manages test environment including database setup
				- Runs different test types based on configuration
				- Cleans up resources after completion

		Dev
			Usage: dev [--db-url <url>] [--port <port>]

			Arguments:
				- --db-url: Database connection URL (overrides DATABASE_URL env var)
				- --port: Server port (overrides PORT env var)

			Behavior:
				- Starts development server with file watching using watchexec
				- Automatically rebuilds and restarts on file changes
				- Invokes build and start commands with arguments

			Examples:
				project dev --db-url "postgres://localhost:5432/mydb" --port 3000
				project dev --port 3000

		Start
			Usage: start [--db-url <url>] [--db-path <path>] [--port <port>]

			Arguments:
				- --db-url: Database connection URL (overrides DATABASE_URL env var)
				- --db-path: SQLite database file path (overrides DB_PATH env var)
				- --port: Server port (overrides PORT env var)

			Behavior:
				- Starts the application server
				- Manages required services (containers) if using local services
				- Kills any existing process using the target port
				- Runs database migration if db.migrate.sql exists
				- Requires server bundle at ./dist/server.bundle.cjs

			Examples:
				project start --db-url "postgres://localhost:5432/mydb" --port 3000
				project start --db-path "./data/myapp.db" --port 3000

		Deploy
			Usage: deploy [--update-level <path|minor|major>] [--include <files>] [--exclude <files>] --repo <url>

			Arguments:
				- --update-level: A semver update level: patch, minor, or major output folder (defaults to patch).
				- --include/--exclude: A list of files in the build output folder to include in, or exclude from, respectively, the deployment. Include is applied first, defaulting to all files, and then the exclude argument is applied, defaulting to no files. 
				- --repo: The URL of a remote git repo to deploy the files to (defaults to https://github.com/danfortsystems/<project-name>).

			Behavior:
				The deploy command, when invoked at the root of any project, should:
				- Ensure that the project is git-wise clean (i.e., no pending changes)
				- Call the build script with the output folder argument set to a temporary folder (not ./dist), using the DATABASE_URL and/or DB_PATH env vars for the --db-url and/or --db-path arguments respectively, and with --db-reset-ok set
				- Update the project version in its main package.json file (according to the semver update level), commit with an appropriate tag, and push
				- Create a package.json file in the build output folder with: package name set to the project name, version set to the current project version, repository set to the main repository, and an additonal "commit_tag" or "commit_hash" property set to the relevant value. The will be no dependencies etc property on this package.json since the build will produce bundled files that do not need building again when deployed. But there could be an engine property.
				- Remove files that should be excluded from the deployment (either because they are not selected by the --include argument, or they are present in the --exclude argument)
				- Intialize a git repo in the build output folder, and set the remote to the target deployment git repo argument
				- Commit and tag appropriately, then push to the target deployment repo
				- Maybe delete the build output folder to clean up

			Examples:
				project deploy --update-level minor --repo https://github.com/user/repo.git
				project deploy --include "*.js,*.css" --exclude "*.map" --repo https://github.com/user/repo.git

			Remarks:
				This deployment approach can also work for GitHub-based deploys to popular PaaS platforms like Render.com. The PaaS project is connected, not to the main project GitHub repo, but to a dedicated deploy-only Github repo, and this deploy repo is what is passed as the --repo argument to the deploy script. So the PaaS does not even asee the source files, only the build files that are staged on the deploy repo. Thus, we also do not need to build on the PaaS again.

		Install
			Usage: install --src <url OR folder path> --name <command-name> [--target <local-install-folder-path>] [--version <version-number-tag>]

			Arguments:
				- --src: Where to get the installation files from: either the URL of a remote Github repo, or the path to a local folder. Required.
				- --name: The package/command name. Used to select the executable to install and as the symlink name. Required.
				- --target: The target local folder path to install the files in. Defaults to ~/.local/share/<name>.
				- --version: The tag of the version number to install (only applicable for Github installs)

			Behavior:
				The install command, when invoked, should:
				- Create the target installation directory if it doesn’t exist
				- Copy or download the installation files from the source (local or remote) into the target folder. For a GitHub repo, HTTPS is used to download the version archive file (e.g., https://github.com/owner/repo/archive/refs/tags/v0.1.0.tar.gz) which is then piped to tar to extract it. If no version argument was provided, the latest main archive is downloaded. After extraction, the contents of the archive’s top-level directory are moved up one level into the root of the target installation directory.
				- Detect the current operating system and architecture (e.g., Darwin→macos, Linux→linux; x86_64→x64, aarch64→arm64) and select the executable to install with platform-specific fallback:
					1. First tries {name}-{os}-{architecture} (e.g., myapp-macos-arm64)
					2. Falls back to {name} (generic, non-platform-specific)
					3. Errors with a listing of available files if neither is found
				- Set proper permissions on the selected executable and create a symlink at ~/.local/bin/<name> pointing to it
				- Do initialization/migration tasks by running the command with --init flag (All installable projects are expected to support a --init flag for one-time initialization tasks)
				- Verify the installation by running the command with --version (All installable projects are expected to support a --version flag for displaying the version)
				- Display installation success message with path information

			Examples:
				install --src https://github.com/user/repo.git --name myapp --version v1.0.0
				install --src ./dist --name myapp --target /custom/install/path

INSTALLATION
	Apptools as a whole and its scripts are coded in such a way that it can use its install script to install itself. Apart from the install command, no other command in AppTools can be run on AppTools itself. The project is hosted at the remote git repo https://github.com/danfortsystems/apptools, with the following file structure:
	

ENVIRONMENT VARIABLES

	Core Variables:
		- NODE_ENV: Build/execute environment (dev or prod), default: dev

	Database Variables:
		- DATABASE_URL: PostgreSQL connection string (format: postgres://user:pass@host:port/dbname)
		- DB_PATH: SQLite database file path

	Container Service Variables:
		- OBJECT_STORAGE_ROOT_URL: Root URL for S3-compatible object storage. When set to a local URL (e.g., http://localhost:9000), enables MinIO container management by AppTools
		- OBJECT_STORAGE_BUCKET: Object storage bucket name. Used to create project-specific storage areas within the shared MinIO container
		- OBJECT_STORAGE_ACCESS_KEY_ID: Access key for object storage authentication (used when OBJECT_STORAGE_ROOT_URL is local)
		- OBJECT_STORAGE_ACCESS_KEY_SECRET: Access key secret for object storage authentication (used when OBJECT_STORAGE_ROOT_URL is local)
		- SMTP_HOST: SMTP server host. When set to a local URL (e.g., http://localhost:1025), enables MailHog container management by AppTools
		- MSG_FROM_EMAIL_ADDRESS: Email address for per-project email separation in MailHog
		- SMS_* (proposed): SMS service configuration variables

	Testing Variables:
		- PLAYWRIGHT_BROWSERS_PATH: Path for Playwright browser installations. When set, triggers Playwright browser installation

	Container Management:
		- Container names are generic (minio, mailhog) for sharing across projects
		- Isolation achieved through environment variables
		- Containers are started/stopped based on presence of relevant env vars

DEVELOPMENT

	Installation
		- Tools are copied to ~/.local/bin/apptools/
		- PATH is updated in ~/.bashrc and ~/.zshrc
		- One-liner installer available via curl script

	Deployment
		- Simple file-based deployment via _deploy script
		- No build process required (scripts are Bash)
		- Tools remain executable without installation

	FUTURE ENHANCEMENTS

		Potential SMS Integration:
			- SMS_* environment variables for SMS testing configuration
			- Container-based SMS gateway or integration with Twilio
			- Environment variable control similar to other services