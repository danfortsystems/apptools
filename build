#!/usr/bin/env bash

# Main build script, intended to run from root of project

# Usage:
	# build [--dest <output path>] [--only app|exc|db] [--db-url <postgres db url>] [--db-path <sqlite db path>] [--db-reset-ok]

# Remarks
	# App build involves typechecking and bundling client & server app code
	# Exc build creates self-contained executable applications (uses bin/main.ts entry point by convention)
	# Db build involves generating db migration script or migration logic
	# Multiple targets can be built in a single command (default: all three if not specified)

# Examples:
	# build --dest <path> --db-url <url>  -- Full build (app, exc, db) to a specified location, targeting a specific db url
	#
	# build --only app,exc [--dest <path>] -- Build app bundles and executables only (no database operations)
	#
	# build --only db --db-reset-ok -- Db build only to ./dist, targeting postgres db at DATABASE_URL and/or sqlite db at DB_PATH. The --db-reset-ok flag allows resetting db schema if migration cannot be applied safely
	#
	# build --only exc [--dest <path>] -- Exc build only, creates self-contained executable for current OS/architecture
	#
	# build --only app [--dest <path>] -- App only build (JS bundles only) to a specific output location
#


# Set immediate exit on error (including undefined variables, pipelines)
set -euo pipefail

# Load utility functions
source "$APPTOOLS_DIR_PATH/_utils"

# Default values
dest_path="./dist"
db_url="${DATABASE_URL:-}"
db_path="${DB_PATH:-}"
db_reset_ok=false
only=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dest)
            dest_path="$2"
            shift 2
            ;;
        --db-url)
            db_url="$2"
            shift 2
            ;;
		--db-path)
            db_path="$2"
            shift 2
            ;;
        --db-reset-ok)
            db_reset_ok=true
            shift
            ;;
        --only)
            only="$2"
            shift 2
            # Validate each target in comma-separated list
            IFS=',' read -ra targets <<< "$only"
            for target in "${targets[@]}"; do
                if [[ "$target" != "app" && "$target" != "exc" && "$target" != "db" ]]; then
                    print_error "Invalid --only value: $target. Must be 'app', 'exc', or 'db'"
                    exit 1
                fi
            done
            ;;
        *)
            print_error "Unknown argument: $1"
            print_error "Usage: build --dest <path> [--db-url <url>] [--db-path <path>] [--db-reset-ok] [--only app,exc,db]"
            exit 1
            ;;
    esac
done

# Log build arguments
print_step "Build started with args: dest=$dest_path, db-url=$db_url, db-path=$db_path, db-reset-ok=$db_reset_ok, only=$only"

# Helper function to check if a target should be built
should_build() {
    local target="$1"
    # If --only is empty, build all targets
    if [[ -z "$only" ]]; then
        return 0
    fi
    # Check if target is in the comma-separated list
    [[ ",$only," == *",$target,"* ]]
}

# Create output directories
mkdir -p "$dest_path/public"

# Type check (for app or exc builds)
if should_build "app" || should_build "exc"; then
    print_header "Type-checking..."
    pnpm exec tsc --noEmit --pretty
    print_step "Done type-checking"
fi

# Build client and server code using esbuild config (for app build)
if should_build "app"; then
    print_header "Building client and server..."
    DEST="$dest_path" NODE_ENV="${NODE_ENV:-development}" node esbuild.config.js
    print_step "Done building client and server"
fi

# Copy static client files (for app build)
if should_build "app"; then
    print_header "Staging static files..."
    cp -R ./source/client/static/* "$dest_path/public/"
    print_step "Done staging static files"
fi

# Build executable (for exc build)
if should_build "exc"; then
    print_header "Building executable..."

    # Check if entry point exists
    if [[ ! -f "bin/main.ts" ]]; then
        print_error "Entry point bin/main.ts not found"
        exit 1
    fi

    # Extract package name from package.json
    if [[ ! -f "package.json" ]]; then
        print_error "package.json not found"
        exit 1
    fi

    package_name=$(node -p "require('./package.json').name" | sed 's/[^a-z0-9-]//g' | tr '[:upper:]' '[:lower:]')

    # Detect OS and architecture
    os=$(detect_os)
    arch=$(detect_arch)

    # Construct output filename
    output_name="${package_name}-${os}-${arch}"
    output_path="$dest_path/$output_name"

    print_step "Building executable: $output_name"

    # Compile with bun
    if ! bun build --compile bin/main.ts --outfile "$output_path"; then
        print_error "Executable compilation failed"
        exit 1
    fi

    print_step "Done building executable: $output_path"
fi

# Build database (for db build)
if should_build "db"; then
    # Check if we have database configuration from command line arguments or environment variables
    if [[ -n "$db_url" ]]; then
        print_header "Building PostgreSQL DB..."
        bash "$APPTOOLS_DIR_PATH/_postgres" --dest "$dest_path" --db-url "$db_url" $( [[ "$db_reset_ok" == true ]] && echo "--db-reset-ok" )
        print_step "PostgreSQL DB build completed"
    elif [[ -n "$db_path" ]]; then
        print_header "Building SQLite DB..."

        bash "$APPTOOLS_DIR_PATH/_sqlite" --dest "$dest_path" --db-path "$db_path" $( [[ "$db_reset_ok" == true ]] && echo "--db-reset-ok" )
        echo "SQLite DB build completed"
    else
        print_error "Can't build DB -- no target config specified."
        print_step "Use --db-url <url> or --db-path <path>, or set DATABASE_URL / DB_PATH env variables."
        exit 1
    fi
fi

# print_step "Build completed successfully"