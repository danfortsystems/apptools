#!/usr/bin/env bash

# Local server start script
# Usage: <runner> serve [--db-url <url>] [--port <port#>], where <runner> is one of:
#	pnpm run (if `pnpm run setup` has been run to setup tooling commands)
#	./tools/_run.sh (to run the command directly from the project root)
#
# Options:
#   --db-url <url>	Database connection URL (overrides DATABASE_URL env var)
#   --port <port#>	Port number for the server (overrides PORT env var)
#
# Examples:
#   ./tools/_run.sh serve				# Start server with env vars
#   pnpm run serve --db-url "postgres://localhost:5432/mydb"	# Use custom database
#   pnpm run serve --port 3000			# Use custom port
#   pnpm run serve --db-url "postgres://localhost:5432/mydb" --port 8080

source ./tools/_utils.sh

# Default to environment variables
DB_URL="$DATABASE_URL"
SERVER_PORT="$PORT"

# Get arguments and override defaults
while [[ $# -gt 0 ]]; do
	case $1 in
		--db-url)
			DB_URL="$2"
			shift 2
			;;
		--port)
			SERVER_PORT="$2"
			shift 2
			;;
		*)
			echo "Unknown argument: $1"
			echo "Usage: serve [--db-url <url>] [--port <port#>]"
			exit 1
			;;
	esac
done

# Validate arguments
if [[ -z "$DB_URL" ]]; then
	print_error "Neither --db-url argument nor DATABASE_URL environment variable is set"
	exit 1
fi
if [[ -z "$SERVER_PORT" ]]; then
	print_error "Neither --port argument nor PORT environment variable is set"
	exit 1
fi

print_header "Serve started with args: db url=$DB_URL, port=$SERVER_PORT"

# Check if server bundle exists
if [[ ! -f "./dist/server.bundle.js" ]]; then
	print_error "Server bundle not found at ./dist/server.bundle.js. Please run 'airkeys build' first."
	exit 1
fi

# Run built db script if present
DB_SCRIPT="./dist/db.migrate.sql"
if [[ -f "$DB_SCRIPT" ]]; then	
	print_step "Running init/migration script '$DB_SCRIPT' on DB"
	
	if psql "$DB_URL" -v ON_ERROR_STOP=1 -v schema=public -f "$DB_SCRIPT"; then
		# Delete db script if it ran successfully
		rm "$DB_SCRIPT"
	else
		print_error "Database migration failed. Aborting server start."
		exit 1
	fi
fi

# Kill any existing process using the target port
# print_step "Checking for existing processes on port $SERVER_PORT..."
EXISTING_PID=$(lsof -ti:$SERVER_PORT 2>/dev/null || true)
if [[ -n "$EXISTING_PID" ]]; then
	print_step "Killing existing process $EXISTING_PID on port $SERVER_PORT..."
	kill -9 $EXISTING_PID 2>/dev/null || true
	sleep 1
fi

# Start MinIO if using local object storage
if [[ -n "$OBJECT_STORAGE_ROOT_URL" ]] && [[ "$OBJECT_STORAGE_ROOT_URL" =~ localhost|127\.0\.0\.1 ]]; then
	print_step "Ensuring MinIO (local object storage) is running..."

	# Start podman machine if not running
	if ! podman machine list 2>/dev/null | grep -qE "Running|Currently running"; then
		print_step "Starting Podman machine..."
		podman machine start >/dev/null 2>&1 || {
			print_warning "Failed to start Podman machine. Continuing anyway..."
		}
	fi

	# Check if minio container exists
	CONTAINER_NAME="minio-airkeys"
	if ! podman ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
		print_step "Creating MinIO container..."
		podman run -d --name "$CONTAINER_NAME" \
			-p 9000:9000 -p 9001:9001 \
			-e "MINIO_ROOT_USER=${OBJECT_STORAGE_ACCESS_KEY_ID:-minioadmin}" \
			-e "MINIO_ROOT_PASSWORD=${OBJECT_STORAGE_ACCESS_KEY_SECRET:-minioadmin}" \
			minio/minio server /data --console-address ":9001" >/dev/null 2>&1 || {
			print_warning "Failed to create MinIO container. Continuing anyway..."
		}
		# Wait for MinIO to start
		sleep 3
	else
		# Check if container is running
		if ! podman ps --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
			print_step "Starting existing MinIO container..."
			podman start "$CONTAINER_NAME" >/dev/null 2>&1 || {
				print_warning "Failed to start MinIO container. Continuing anyway..."
			}
		fi
	fi

	# Create bucket if it doesn't exist
	BUCKET_NAME="${OBJECT_STORAGE_BUCKET:-airkeys}"
	if podman exec "$CONTAINER_NAME" mc alias set local http://localhost:9000 "${OBJECT_STORAGE_ACCESS_KEY_ID:-minioadmin}" "${OBJECT_STORAGE_ACCESS_KEY_SECRET:-minioadmin}" >/dev/null 2>&1; then
		podman exec "$CONTAINER_NAME" mc mb "local/${BUCKET_NAME}" --ignore-existing >/dev/null 2>&1 || true
	fi
fi

# Start MailHog if using local SMTP server
if [[ -n "${SMTP_HOST:-}" ]] && [[ "$SMTP_HOST" =~ localhost|127\.0\.0\.1 ]]; then
	print_step "Ensuring MailHog (local email testing) is running..."

	# Start podman machine if not running
	if ! podman machine list 2>/dev/null | grep -qE "Running|Currently running"; then
		print_step "Starting Podman machine..."
		podman machine start >/dev/null 2>&1 || {
			print_warning "Failed to start Podman machine. Continuing anyway..."
		}
	fi

	# Check if mailhog container exists
	CONTAINER_NAME="mailhog-airkeys"
	if ! podman ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
		print_step "Creating MailHog container..."
		podman run -d --name "$CONTAINER_NAME" \
			-p 1025:1025 -p 8025:8025 \
			mailhog/mailhog >/dev/null 2>&1 || {
			print_warning "Failed to create MailHog container. Continuing anyway..."
		}
		# Wait for MailHog to start
		sleep 3
	else
		# Check if container is running
		if ! podman ps --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
			print_step "Starting existing MailHog container..."
			podman start "$CONTAINER_NAME" >/dev/null 2>&1 || {
				print_warning "Failed to start MailHog container. Continuing anyway..."
			}
		fi
	fi
fi

# Start server
DATABASE_URL=$DB_URL PORT=$SERVER_PORT node ./dist/server.bundle.js
