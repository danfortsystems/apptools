#!/usr/bin/env bash

# Starts the local server with specified database configuration

# Usage:
	# start [--db-url <postgres url>] [--db-path <sqlite path>] [--port <port#>]

# Remarks:
	# The script defaults the --db-url or --db-path argument to the DATABASE_URL/DB_PATH env vars respectively. If neither the arg nor env var is passed/set, the script will raise an error and exit.
	# Server bundle must exist at ./dist/server.bundle.cjs
	# Database migration is run if ./dist/db.migrate.sql exists

# Examples:
	# start --db-url "postgres://localhost:5432/mydb" --port 3000
	# start --db-path "./data/myapp.db" --port 3000
#

# Set immediate exit on error (including undefined variables, pipelines)
set -euo pipefail

# Load utility functions
source "$(dirname "$0")/_utils.sh"

# Default to environment variables
DB_URL="${DATABASE_URL:-}"
DB_PATH="${DB_PATH:-}"
SERVER_PORT="${PORT:-}"

# Server bundle path
SERVER_BUNDLE="./dist/server.bundle.cjs"


# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --db-url)
            DB_URL="$2"
            shift 2
            ;;
        --db-path)
            DB_PATH="$2"
            shift 2
            ;;
        --port)
            SERVER_PORT="$2"
            shift 2
            ;;
        *)
            print_error "Unknown argument: $1"
            print_error "Usage: start [--db-url <url>] [--db-path <path>] [--port <port#>]"
            exit 1
            ;;
    esac
done

# Validate database configuration
if [[ -z "$DB_URL" && -z "$DB_PATH" ]]; then
    print_error "Neither database URL nor path specified."
    print_error "Use --db-url <url> or --db-path <path>, or set DATABASE_URL / DB_PATH environment variables."
    exit 1
fi

# Validate port
if [[ -z "$SERVER_PORT" ]]; then
    print_error "Neither --port argument nor PORT environment variable is set"
    exit 1
fi

# Log start arguments
print_step "Start arguments:"
if [[ -n "$DB_URL" ]]; then
	print_step "PostgreSQL DB URL: $DB_URL"
elif [[ -n "$DB_PATH" ]]; then
	print_step "SQLite DB path: $DB_PATH"
fi
print_step "Server port: ${SERVER_PORT}\n"

# Check if server bundle exists
if [[ ! -f "$SERVER_BUNDLE" ]]; then
	print_error "Server bundle not found at $SERVER_BUNDLE. Please run 'airkeys build' first."
	exit 1
fi

# Run built db script if present
DB_SCRIPT="./dist/db.migrate.sql"
if [[ -f "$DB_SCRIPT" ]]; then
	print_step "Running init/migration script '$DB_SCRIPT' on DB"

	if [[ -n "$DB_URL" ]]; then
		# PostgreSQL
		if ! psql "$DB_URL" -v ON_ERROR_STOP=1 -v schema=public -f "$DB_SCRIPT"; then
			print_error "PostgreSQL database migration failed. Aborting server start."
			exit 1
		fi
	elif [[ -n "$DB_PATH" ]]; then
		# SQLite
		if ! sqlite3 "$DB_PATH" < "$DB_SCRIPT"; then
			print_error "SQLite database migration failed. Aborting server start."
			exit 1
		fi
	fi

	# Delete db script if it ran successfully
	rm "$DB_SCRIPT"
fi

# Kill any existing process using the target port
# print_step "Checking for existing processes on port $SERVER_PORT..."
EXISTING_PID=$(lsof -ti:$SERVER_PORT 2>/dev/null || true)
if [[ -n "$EXISTING_PID" ]]; then
	print_step "Killing existing process $EXISTING_PID on port $SERVER_PORT..."
	kill -9 $EXISTING_PID 2>/dev/null || true
	sleep 1
fi

# Start MinIO if using local object storage
if [[ -n "${OBJECT_STORAGE_ROOT_URL:-}" ]] && [[ "$OBJECT_STORAGE_ROOT_URL" =~ localhost|127\.0\.0\.1 ]]; then
	print_step "Ensuring MinIO (local object storage) is running..."

	# Start podman machine if not running
	if ! podman machine list 2>/dev/null | grep -qE "Running|Currently running"; then
		print_step "Starting Podman machine..."
		podman machine start >/dev/null 2>&1 || {
			print_warning "Failed to start Podman machine. Continuing anyway..."
		}
	fi

	# Check if minio container exists
	CONTAINER_NAME="minio-airkeys"
	if ! podman ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
		print_step "Creating MinIO container..."
		podman run -d --name "$CONTAINER_NAME" \
			-p 9000:9000 -p 9001:9001 \
			-e "MINIO_ROOT_USER=${OBJECT_STORAGE_ACCESS_KEY_ID:-minioadmin}" \
			-e "MINIO_ROOT_PASSWORD=${OBJECT_STORAGE_ACCESS_KEY_SECRET:-minioadmin}" \
			minio/minio server /data --console-address ":9001" >/dev/null 2>&1 || {
			print_warning "Failed to create MinIO container. Continuing anyway..."
		}
		# Wait for MinIO to start
		sleep 3
	else
		# Check if container is running
		if ! podman ps --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
			print_step "Starting existing MinIO container..."
			podman start "$CONTAINER_NAME" >/dev/null 2>&1 || {
				print_warning "Failed to start MinIO container. Continuing anyway..."
			}
		fi
	fi

	# Create bucket if it doesn't exist
	BUCKET_NAME="${OBJECT_STORAGE_BUCKET:-airkeys}"
	if podman exec "$CONTAINER_NAME" mc alias set local http://localhost:9000 "${OBJECT_STORAGE_ACCESS_KEY_ID:-minioadmin}" "${OBJECT_STORAGE_ACCESS_KEY_SECRET:-minioadmin}" >/dev/null 2>&1; then
		podman exec "$CONTAINER_NAME" mc mb "local/${BUCKET_NAME}" --ignore-existing >/dev/null 2>&1 || true
	fi
fi

# Start MailHog if using local SMTP server
if [[ -n "${SMTP_HOST:-}" ]] && [[ "$SMTP_HOST" =~ localhost|127\.0\.0\.1 ]]; then
	print_step "Ensuring MailHog (local email testing) is running..."

	# Start podman machine if not running
	if ! podman machine list 2>/dev/null | grep -qE "Running|Currently running"; then
		print_step "Starting Podman machine..."
		podman machine start >/dev/null 2>&1 || {
			print_warning "Failed to start Podman machine. Continuing anyway..."
		}
	fi

	# Check if mailhog container exists
	CONTAINER_NAME="mailhog-airkeys"
	if ! podman ps -a --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
		print_step "Creating MailHog container..."
		podman run -d --name "$CONTAINER_NAME" \
			-p 1025:1025 -p 8025:8025 \
			mailhog/mailhog >/dev/null 2>&1 || {
			print_warning "Failed to create MailHog container. Continuing anyway..."
		}
		# Wait for MailHog to start
		sleep 3
	else
		# Check if container is running
		if ! podman ps --format "{{.Names}}" 2>/dev/null | grep -q "^${CONTAINER_NAME}$"; then
			print_step "Starting existing MailHog container..."
			podman start "$CONTAINER_NAME" >/dev/null 2>&1 || {
				print_warning "Failed to start MailHog container. Continuing anyway..."
			}
		fi
	fi
fi

# Start server with appropriate database configuration
if [[ -n "$DB_URL" ]]; then
	DATABASE_URL=$DB_URL PORT=$SERVER_PORT node "$SERVER_BUNDLE"
elif [[ -n "$DB_PATH" ]]; then
	DB_PATH=$DB_PATH PORT=$SERVER_PORT node "$SERVER_BUNDLE"
fi
